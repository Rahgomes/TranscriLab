generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// === Enums ===

enum TranscriptionStatus {
  PENDING
  PROCESSING
  COMPLETED
  ERROR
}

enum AudioEventType {
  LAUGHTER
  APPLAUSE
  MUSIC
  SILENCE
  CROSSTALK
  OTHER
}

enum DerivedContentType {
  MEETING_MINUTES
  TASK_LIST
  CLIENT_EMAIL
  WHATSAPP_MESSAGE
  LINKEDIN_POST
  VIDEO_SCRIPT
  FAQ
}

// === Models ===

model Category {
  id        String   @id @default(uuid())
  name      String   @db.VarChar(100)
  color     String   @db.VarChar(7)
  isDefault Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  transcriptions Transcription[]

  @@map("categories")
}

model Transcription {
  id                        String              @id @default(uuid())
  fileName                  String              @db.VarChar(500)
  originalFileName          String              @db.VarChar(500)
  fileSize                  Int
  duration                  Float?
  transcription             String              @db.Text
  originalTranscriptionText String?             @db.Text
  currentVersion            Int                 @default(0)
  language                  String?             @default("pt") @db.VarChar(10)
  status                    TranscriptionStatus @default(COMPLETED)
  hasAudio                  Boolean             @default(false)
  audioMimeType             String?             @db.VarChar(100)
  hasDiarization            Boolean             @default(false)
  speakerCount              Int?
  createdAt                 DateTime            @default(now())
  updatedAt                 DateTime            @updatedAt

  categoryId String?
  category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  summary   Summary?
  audioFile AudioFile?
  segments  TranscriptionSegment[]
  events    AudioEvent[]
  versions        TranscriptionVersion[]
  derivedContents DerivedContent[]
  hasEvents       Boolean             @default(false)
  source          String?             @default("upload") @db.VarChar(20)

  @@index([categoryId])
  @@index([createdAt(sort: Desc)])
  @@index([fileName])
  @@map("transcriptions")
}

model TranscriptionSegment {
  id           String  @id @default(uuid())
  index        Int
  speaker      String  @db.VarChar(50)
  text         String  @db.Text
  originalText String? @db.Text
  speakerLabel String? @db.VarChar(100)
  startTime    Float
  endTime      Float

  transcriptionId String
  transcription   Transcription @relation(fields: [transcriptionId], references: [id], onDelete: Cascade)

  @@index([transcriptionId])
  @@index([transcriptionId, index])
  @@index([transcriptionId, startTime])
  @@map("transcription_segments")
}

model Summary {
  id          String   @id @default(uuid())
  summary     String   @db.Text
  insights    String[]
  tokensUsed  Int      @default(0)
  generatedAt DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  transcriptionId String        @unique
  transcription   Transcription @relation(fields: [transcriptionId], references: [id], onDelete: Cascade)

  @@map("summaries")
}

model AudioEvent {
  id        String         @id @default(uuid())
  type      AudioEventType
  startTime Float
  endTime   Float
  confidence Float
  description String?      @db.Text
  source     String        @db.VarChar(50)
  createdAt  DateTime      @default(now())

  transcriptionId String
  transcription   Transcription @relation(fields: [transcriptionId], references: [id], onDelete: Cascade)

  @@index([transcriptionId])
  @@index([transcriptionId, startTime])
  @@index([transcriptionId, type])
  @@map("audio_events")
}

model TranscriptionVersion {
  id              String   @id @default(uuid())
  versionNumber   Int
  editedAt        DateTime @default(now())
  editorId        String?  @db.VarChar(100)
  changesSummary  String   @db.Text
  snapshot        Json     @db.JsonB

  transcriptionId String
  transcription   Transcription @relation(fields: [transcriptionId], references: [id], onDelete: Cascade)

  @@unique([transcriptionId, versionNumber])
  @@index([transcriptionId])
  @@index([transcriptionId, editedAt])
  @@map("transcription_versions")
}

model DerivedContent {
  id        String             @id @default(uuid())
  type      DerivedContentType
  title     String             @db.VarChar(300)
  content   String             @db.Text
  tokensUsed Int               @default(0)
  modelUsed  String            @db.VarChar(50)
  metadata   Json?             @db.JsonB
  createdAt  DateTime          @default(now())

  transcriptionId String
  transcription   Transcription @relation(fields: [transcriptionId], references: [id], onDelete: Cascade)

  @@index([transcriptionId])
  @@index([transcriptionId, type])
  @@map("derived_contents")
}

model AudioFile {
  id        String   @id @default(uuid())
  fileName  String   @db.VarChar(500)
  mimeType  String   @db.VarChar(100)
  sizeBytes Int
  createdAt DateTime @default(now())

  transcriptionId String        @unique
  transcription   Transcription @relation(fields: [transcriptionId], references: [id], onDelete: Cascade)

  @@map("audio_files")
}
